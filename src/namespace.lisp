;;;; This file is a part of IN-NOMINE.
;;;; Copyright (c) 2015 Masataro Asai (guicho2.71828@gmail.com),
;;;;               2022 Micha≈Ç "phoe" Herda (phoe@disroot.org)

(in-package #:in-nomine)

(deftype unbound-behavior () '(member :error :errorp))

;; Null ACCESSOR: no autogenerated accessors
;; Null MAKUNBOUND-SYMBOL: no makunbound is generated
;; Null BOUNDP-SYMBOL: no boundp is generated
;; Null ACCESSOR, MAKUNBOUND-SYMBOL, and BOUNDP-SYMBOL: no binding hash table
;;
;; Null TYPE-NAME: no type is generated
;; Null DOCUMENTATION-TYPE: no documentation hash table
;; * Documentation of type T for namespace objects is always available
;;
;; Null CONDITION-NAME: no condition is generated, and:
;; * True ERRORP-ARG-IN-ACCESSOR-P:
;;  * compile-time-error
;; * True ERROR-WHEN-NOT-FOUND-P:
;;   * compile-time error
;; * Null ERROR-WHEN-NOT-FOUND-P and ERRORP-ARG-IN-ACCESSOR-P:
;;  * no error/restart facility in reader function

(macrolet ((e () '(error "Internal error - not all args were provided.")))
  (defstruct (namespace (:constructor %make-namespace))
    (name                      (e) :type symbol  :read-only t)
    (name-type                 (e) :type t       :read-only t)
    (value-type                (e) :type t       :read-only t)
    (accessor                  (e) :type symbol  :read-only t)
    (condition-name            (e) :type symbol  :read-only t)
    (type-name                 (e) :type symbol  :read-only t)
    (makunbound-symbol         (e) :type symbol  :read-only t)
    (boundp-symbol             (e) :type symbol  :read-only t)
    (documentation-type        (e) :type symbol  :read-only t)
    (hash-table-test           (e) :type symbol  :read-only t)
    (error-when-not-found-p    (e) :type boolean :read-only t)
    (errorp-arg-in-accessor-p  (e) :type boolean :read-only t)
    (default-arg-in-accessor-p (e) :type boolean :read-only t)
    (documentation             (e) :type (or null string))
    (binding-table             (e) :type (or null hash-table))
    (documentation-table       (e) :type (or null hash-table))))

(defun check-namespace-parameters (namespace)
  (when (null (namespace-condition-name namespace))
    (when (namespace-error-when-not-found-p namespace)
      (error "Cannot provide ERROR-WHEN-NOT-FOUND-P when CONDITION-NAME ~
              is null."))
    (when (namespace-errorp-arg-in-accessor-p namespace)
      (error "Cannot provide ERRORP-ARG-IN-ACCESSOR-P when CONDITION-NAME ~
              is null."))))

(defun make-namespace
    (name &key
            (name-type 'symbol)
            (value-type 't)
            (accessor (symbolicate '#:symbol- name))
            (condition-name (symbolicate '#:unbound- name))
            (type-name (symbolicate name '#:-type))
            (makunbound-symbol (symbolicate name '#:-makunbound))
            (boundp-symbol (symbolicate name '#:-boundp))
            (documentation-type nil documentation-type-p)
            (hash-table-test 'eq)
            (error-when-not-found-p t)
            (errorp-arg-in-accessor-p nil)
            (default-arg-in-accessor-p t)
            (documentation nil))
  (let ((namespace (%make-namespace
                    :name name :name-type name-type :value-type value-type
                    :accessor accessor
                    :condition-name condition-name :type-name type-name
                    :makunbound-symbol makunbound-symbol
                    :boundp-symbol boundp-symbol
                    :error-when-not-found-p error-when-not-found-p
                    :errorp-arg-in-accessor-p errorp-arg-in-accessor-p
                    :default-arg-in-accessor-p default-arg-in-accessor-p
                    :documentation-type (if documentation-type-p
                                            documentation-type
                                            name)
                    :hash-table-test hash-table-test
                    :binding-table
                    (if (and (null accessor)
                             (null makunbound-symbol)
                             (null boundp-symbol))
                        nil
                        (make-hash-table :test hash-table-test))
                    :documentation-table
                    (if (and documentation-type-p (null documentation-type))
                        nil
                        (make-hash-table :test hash-table-test))
                    :documentation documentation)))
    (check-namespace-parameters namespace)
    namespace))

(defmethod print-object ((namespace namespace) stream)
  (print-unreadable-object (namespace stream :type t)
    (let ((hash-table (namespace-binding-table namespace)))
      (format stream "~S ~:[(external)~;(~D binding~:*~P)~]"
              (namespace-name namespace)
              hash-table
              (when hash-table
                (hash-table-count (namespace-binding-table namespace)))))))

(defparameter *namespace-args*
  '(:value-type namespace :documentation-type nil))

(defvar *namespaces*
  (apply #'make-namespace 'namespace *namespace-args*))

(defmethod documentation ((namespace namespace) (type (eql 't)))
  (namespace-documentation namespace))

(defmethod (setf documentation) (newdoc (namespace namespace) (type (eql 't)))
  (setf (namespace-documentation namespace) newdoc))

(defmethod documentation ((name symbol) (type (eql 'namespace)))
  (namespace-documentation (symbol-namespace name)))

(defmethod (setf documentation) (newdoc (name symbol) (type (eql 'namespace)))
  (setf (namespace-documentation (symbol-namespace name)) newdoc))

(defun ensure-namespace (name &rest args)
  (let ((hash-table (namespace-binding-table *namespaces*)))
    (multiple-value-bind (value foundp) (gethash name hash-table)
      (if foundp
          value
          (apply #'make-namespace name args)))))

(setf *namespaces* (apply #'ensure-namespace 'namespace *namespace-args*)
      (gethash 'namespace (namespace-binding-table *namespaces*)) *namespaces*)
